// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notifications.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const archiveNotification = `-- name: ArchiveNotification :one
UPDATE notifications
SET archived = TRUE,
    snoozed_until = NULL,
    snoozed_at = NULL,
    effective_sort_date = COALESCE(github_updated_at, imported_at)
WHERE github_id = $1
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

func (q *Queries) ArchiveNotification(ctx context.Context, githubID string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, archiveNotification, githubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const bulkArchiveNotifications = `-- name: BulkArchiveNotifications :execrows
UPDATE notifications
SET archived = true,
    snoozed_until = NULL,
    snoozed_at = NULL,
    effective_sort_date = COALESCE(github_updated_at, imported_at)
WHERE github_id = ANY($1::text[])
`

func (q *Queries) BulkArchiveNotifications(ctx context.Context, githubIds []string) (int64, error) {
	result, err := q.db.ExecContext(ctx, bulkArchiveNotifications, pq.Array(githubIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const bulkMarkNotificationsFiltered = `-- name: BulkMarkNotificationsFiltered :execrows
UPDATE notifications
SET filtered = TRUE
WHERE github_id = ANY($1::text[])
`

func (q *Queries) BulkMarkNotificationsFiltered(ctx context.Context, githubIds []string) (int64, error) {
	result, err := q.db.ExecContext(ctx, bulkMarkNotificationsFiltered, pq.Array(githubIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const bulkMarkNotificationsRead = `-- name: BulkMarkNotificationsRead :execrows
UPDATE notifications
SET is_read = true
WHERE github_id = ANY($1::text[])
`

func (q *Queries) BulkMarkNotificationsRead(ctx context.Context, githubIds []string) (int64, error) {
	result, err := q.db.ExecContext(ctx, bulkMarkNotificationsRead, pq.Array(githubIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const bulkMarkNotificationsUnfiltered = `-- name: BulkMarkNotificationsUnfiltered :execrows
UPDATE notifications
SET filtered = FALSE
WHERE github_id = ANY($1::text[])
`

func (q *Queries) BulkMarkNotificationsUnfiltered(ctx context.Context, githubIds []string) (int64, error) {
	result, err := q.db.ExecContext(ctx, bulkMarkNotificationsUnfiltered, pq.Array(githubIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const bulkMarkNotificationsUnread = `-- name: BulkMarkNotificationsUnread :execrows
UPDATE notifications
SET is_read = false
WHERE github_id = ANY($1::text[])
`

func (q *Queries) BulkMarkNotificationsUnread(ctx context.Context, githubIds []string) (int64, error) {
	result, err := q.db.ExecContext(ctx, bulkMarkNotificationsUnread, pq.Array(githubIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const bulkMuteNotifications = `-- name: BulkMuteNotifications :execrows
UPDATE notifications
SET muted = true,
    snoozed_until = NULL,
    snoozed_at = NULL,
    effective_sort_date = COALESCE(github_updated_at, imported_at)
WHERE github_id = ANY($1::text[])
`

func (q *Queries) BulkMuteNotifications(ctx context.Context, githubIds []string) (int64, error) {
	result, err := q.db.ExecContext(ctx, bulkMuteNotifications, pq.Array(githubIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const bulkSnoozeNotifications = `-- name: BulkSnoozeNotifications :execrows
UPDATE notifications
SET snoozed_until = $1,
    snoozed_at = NOW(),
    effective_sort_date = $1
WHERE github_id = ANY($2::text[])
`

type BulkSnoozeNotificationsParams struct {
	SnoozedUntil sql.NullTime
	GithubIds    []string
}

func (q *Queries) BulkSnoozeNotifications(ctx context.Context, arg BulkSnoozeNotificationsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, bulkSnoozeNotifications, arg.SnoozedUntil, pq.Array(arg.GithubIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const bulkStarNotifications = `-- name: BulkStarNotifications :execrows
UPDATE notifications
SET starred = TRUE
WHERE github_id = ANY($1::text[])
`

func (q *Queries) BulkStarNotifications(ctx context.Context, githubIds []string) (int64, error) {
	result, err := q.db.ExecContext(ctx, bulkStarNotifications, pq.Array(githubIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const bulkUnarchiveNotifications = `-- name: BulkUnarchiveNotifications :execrows
UPDATE notifications
SET archived = false
WHERE github_id = ANY($1::text[])
`

func (q *Queries) BulkUnarchiveNotifications(ctx context.Context, githubIds []string) (int64, error) {
	result, err := q.db.ExecContext(ctx, bulkUnarchiveNotifications, pq.Array(githubIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const bulkUnmuteNotifications = `-- name: BulkUnmuteNotifications :execrows
UPDATE notifications
SET muted = false
WHERE github_id = ANY($1::text[])
`

func (q *Queries) BulkUnmuteNotifications(ctx context.Context, githubIds []string) (int64, error) {
	result, err := q.db.ExecContext(ctx, bulkUnmuteNotifications, pq.Array(githubIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const bulkUnsnoozeNotifications = `-- name: BulkUnsnoozeNotifications :execrows
UPDATE notifications
SET snoozed_until = NULL,
    snoozed_at = NULL,
    effective_sort_date = COALESCE(github_updated_at, imported_at)
WHERE github_id = ANY($1::text[])
`

func (q *Queries) BulkUnsnoozeNotifications(ctx context.Context, githubIds []string) (int64, error) {
	result, err := q.db.ExecContext(ctx, bulkUnsnoozeNotifications, pq.Array(githubIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const bulkUnstarNotifications = `-- name: BulkUnstarNotifications :execrows
UPDATE notifications
SET starred = FALSE
WHERE github_id = ANY($1::text[])
`

func (q *Queries) BulkUnstarNotifications(ctx context.Context, githubIds []string) (int64, error) {
	result, err := q.db.ExecContext(ctx, bulkUnstarNotifications, pq.Array(githubIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getNotificationByGithubID = `-- name: GetNotificationByGithubID :one
SELECT id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
FROM notifications
WHERE github_id = $1
`

func (q *Queries) GetNotificationByGithubID(ctx context.Context, githubID string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, getNotificationByGithubID, githubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const getNotificationByID = `-- name: GetNotificationByID :one
SELECT id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
FROM notifications
WHERE id = $1
`

func (q *Queries) GetNotificationByID(ctx context.Context, id int64) (Notification, error) {
	row := q.db.QueryRowContext(ctx, getNotificationByID, id)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const listNotifications = `-- name: ListNotifications :many
SELECT id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
FROM notifications
ORDER BY github_updated_at DESC NULLS LAST, imported_at DESC
`

func (q *Queries) ListNotifications(ctx context.Context) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, listNotifications)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.GithubID,
			&i.RepositoryID,
			&i.PullRequestID,
			&i.SubjectType,
			&i.SubjectTitle,
			&i.SubjectUrl,
			&i.SubjectLatestCommentUrl,
			&i.Reason,
			&i.Archived,
			&i.GithubUnread,
			&i.GithubUpdatedAt,
			&i.GithubLastReadAt,
			&i.GithubUrl,
			&i.GithubSubscriptionUrl,
			&i.ImportedAt,
			&i.Payload,
			&i.SubjectRaw,
			&i.SubjectFetchedAt,
			&i.AuthorLogin,
			&i.AuthorID,
			&i.IsRead,
			&i.Muted,
			&i.SnoozedUntil,
			&i.EffectiveSortDate,
			&i.SnoozedAt,
			&i.Starred,
			&i.Filtered,
			pq.Array(&i.TagIds),
			&i.SubjectNumber,
			&i.SubjectState,
			&i.SubjectMerged,
			&i.SubjectStateReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotificationsForRepository = `-- name: ListNotificationsForRepository :many
SELECT id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
FROM notifications
WHERE repository_id = $1
ORDER BY github_updated_at DESC NULLS LAST, imported_at DESC
`

func (q *Queries) ListNotificationsForRepository(ctx context.Context, repositoryID int64) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, listNotificationsForRepository, repositoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.GithubID,
			&i.RepositoryID,
			&i.PullRequestID,
			&i.SubjectType,
			&i.SubjectTitle,
			&i.SubjectUrl,
			&i.SubjectLatestCommentUrl,
			&i.Reason,
			&i.Archived,
			&i.GithubUnread,
			&i.GithubUpdatedAt,
			&i.GithubLastReadAt,
			&i.GithubUrl,
			&i.GithubSubscriptionUrl,
			&i.ImportedAt,
			&i.Payload,
			&i.SubjectRaw,
			&i.SubjectFetchedAt,
			&i.AuthorLogin,
			&i.AuthorID,
			&i.IsRead,
			&i.Muted,
			&i.SnoozedUntil,
			&i.EffectiveSortDate,
			&i.SnoozedAt,
			&i.Starred,
			&i.Filtered,
			pq.Array(&i.TagIds),
			&i.SubjectNumber,
			&i.SubjectState,
			&i.SubjectMerged,
			&i.SubjectStateReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markNotificationFiltered = `-- name: MarkNotificationFiltered :one
UPDATE notifications
SET filtered = TRUE
WHERE github_id = $1
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

func (q *Queries) MarkNotificationFiltered(ctx context.Context, githubID string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, markNotificationFiltered, githubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const markNotificationRead = `-- name: MarkNotificationRead :one
UPDATE notifications
SET is_read = true
WHERE github_id = $1
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

func (q *Queries) MarkNotificationRead(ctx context.Context, githubID string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, markNotificationRead, githubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const markNotificationUnfiltered = `-- name: MarkNotificationUnfiltered :one
UPDATE notifications
SET filtered = FALSE
WHERE github_id = $1
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

func (q *Queries) MarkNotificationUnfiltered(ctx context.Context, githubID string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, markNotificationUnfiltered, githubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const markNotificationUnread = `-- name: MarkNotificationUnread :one
UPDATE notifications
SET is_read = false
WHERE github_id = $1
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

func (q *Queries) MarkNotificationUnread(ctx context.Context, githubID string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, markNotificationUnread, githubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const muteNotification = `-- name: MuteNotification :one
UPDATE notifications
SET muted = true,
    snoozed_until = NULL,
    snoozed_at = NULL,
    effective_sort_date = COALESCE(github_updated_at, imported_at)
WHERE github_id = $1
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

func (q *Queries) MuteNotification(ctx context.Context, githubID string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, muteNotification, githubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const snoozeNotification = `-- name: SnoozeNotification :one
UPDATE notifications
SET snoozed_until = $1,
    snoozed_at = NOW(),
    effective_sort_date = $1
WHERE github_id = $2
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

type SnoozeNotificationParams struct {
	SnoozedUntil sql.NullTime
	GithubID     string
}

func (q *Queries) SnoozeNotification(ctx context.Context, arg SnoozeNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, snoozeNotification, arg.SnoozedUntil, arg.GithubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const starNotification = `-- name: StarNotification :one
UPDATE notifications
SET starred = TRUE
WHERE github_id = $1
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

func (q *Queries) StarNotification(ctx context.Context, githubID string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, starNotification, githubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const unarchiveNotification = `-- name: UnarchiveNotification :one
UPDATE notifications
SET archived = FALSE
WHERE github_id = $1
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

func (q *Queries) UnarchiveNotification(ctx context.Context, githubID string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, unarchiveNotification, githubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const unmuteNotification = `-- name: UnmuteNotification :one
UPDATE notifications
SET muted = false
WHERE github_id = $1
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

func (q *Queries) UnmuteNotification(ctx context.Context, githubID string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, unmuteNotification, githubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const unsnoozeNotification = `-- name: UnsnoozeNotification :one
UPDATE notifications
SET snoozed_until = NULL,
    snoozed_at = NULL,
    effective_sort_date = COALESCE(github_updated_at, imported_at)
WHERE github_id = $1
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

func (q *Queries) UnsnoozeNotification(ctx context.Context, githubID string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, unsnoozeNotification, githubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const unstarNotification = `-- name: UnstarNotification :one
UPDATE notifications
SET starred = FALSE
WHERE github_id = $1
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

func (q *Queries) UnstarNotification(ctx context.Context, githubID string) (Notification, error) {
	row := q.db.QueryRowContext(ctx, unstarNotification, githubID)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}

const updateNotificationSubject = `-- name: UpdateNotificationSubject :exec
UPDATE notifications
SET subject_raw = $1,
    subject_fetched_at = $2,
    pull_request_id = $3,
    subject_number = $4,
    subject_state = $5,
    subject_merged = $6,
    subject_state_reason = $7
WHERE github_id = $8
`

type UpdateNotificationSubjectParams struct {
	SubjectRaw         pqtype.NullRawMessage
	SubjectFetchedAt   sql.NullTime
	PullRequestID      sql.NullInt64
	SubjectNumber      sql.NullInt32
	SubjectState       sql.NullString
	SubjectMerged      sql.NullBool
	SubjectStateReason sql.NullString
	GithubID           string
}

func (q *Queries) UpdateNotificationSubject(ctx context.Context, arg UpdateNotificationSubjectParams) error {
	_, err := q.db.ExecContext(ctx, updateNotificationSubject,
		arg.SubjectRaw,
		arg.SubjectFetchedAt,
		arg.PullRequestID,
		arg.SubjectNumber,
		arg.SubjectState,
		arg.SubjectMerged,
		arg.SubjectStateReason,
		arg.GithubID,
	)
	return err
}

const upsertNotification = `-- name: UpsertNotification :one
INSERT INTO notifications (
    github_id,
    repository_id,
    pull_request_id,
    subject_type,
    subject_title,
    subject_url,
    subject_latest_comment_url,
    reason,
    github_unread,
    github_updated_at,
    github_last_read_at,
    github_url,
    github_subscription_url,
    payload,
    subject_raw,
    subject_fetched_at,
    author_login,
    author_id,
    subject_number,
    subject_state,
    subject_merged,
    subject_state_reason,
    effective_sort_date
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19,
    $20,
    $21,
    $22,
    $10
)
ON CONFLICT (github_id) DO UPDATE
SET repository_id = EXCLUDED.repository_id,
    pull_request_id = EXCLUDED.pull_request_id,
    subject_type = EXCLUDED.subject_type,
    subject_title = EXCLUDED.subject_title,
    subject_url = EXCLUDED.subject_url,
    subject_latest_comment_url = EXCLUDED.subject_latest_comment_url,
    reason = EXCLUDED.reason,
    github_unread = EXCLUDED.github_unread,
    github_updated_at = EXCLUDED.github_updated_at,
    github_last_read_at = EXCLUDED.github_last_read_at,
    github_url = EXCLUDED.github_url,
    github_subscription_url = EXCLUDED.github_subscription_url,
    payload = EXCLUDED.payload,
    subject_raw = EXCLUDED.subject_raw,
    subject_fetched_at = EXCLUDED.subject_fetched_at,
    author_login = EXCLUDED.author_login,
    author_id = EXCLUDED.author_id,
    subject_number = EXCLUDED.subject_number,
    subject_state = EXCLUDED.subject_state,
    subject_merged = EXCLUDED.subject_merged,
    subject_state_reason = EXCLUDED.subject_state_reason,
    imported_at = now(),
    -- Smart status updates on sync
    is_read = CASE
        WHEN notifications.muted THEN notifications.is_read
        WHEN EXCLUDED.github_updated_at IS DISTINCT FROM notifications.github_updated_at
        THEN false
        ELSE notifications.is_read
    END,
    archived = CASE
        WHEN notifications.muted THEN notifications.archived
        WHEN EXCLUDED.github_updated_at IS DISTINCT FROM notifications.github_updated_at
        THEN false
        ELSE notifications.archived
    END,
    -- Preserve snoozed_until: time-based snooze, not update-triggered
    snoozed_until = notifications.snoozed_until,
    -- Always preserve muted status.
    muted = notifications.muted,
    -- Always preserve filtered status (managed by rules).
    filtered = notifications.filtered,
    -- Update effective_sort_date: use existing snoozed_until if set, otherwise use new github_updated_at
    effective_sort_date = COALESCE(notifications.snoozed_until, EXCLUDED.github_updated_at)
RETURNING id, github_id, repository_id, pull_request_id, subject_type, subject_title, subject_url, subject_latest_comment_url, reason, archived, github_unread, github_updated_at, github_last_read_at, github_url, github_subscription_url, imported_at, payload, subject_raw, subject_fetched_at, author_login, author_id, is_read, muted, snoozed_until, effective_sort_date, snoozed_at, starred, filtered, tag_ids, subject_number, subject_state, subject_merged, subject_state_reason
`

type UpsertNotificationParams struct {
	GithubID                string
	RepositoryID            int64
	PullRequestID           sql.NullInt64
	SubjectType             string
	SubjectTitle            string
	SubjectUrl              sql.NullString
	SubjectLatestCommentUrl sql.NullString
	Reason                  sql.NullString
	GithubUnread            sql.NullBool
	GithubUpdatedAt         sql.NullTime
	GithubLastReadAt        sql.NullTime
	GithubUrl               sql.NullString
	GithubSubscriptionUrl   sql.NullString
	Payload                 pqtype.NullRawMessage
	SubjectRaw              pqtype.NullRawMessage
	SubjectFetchedAt        sql.NullTime
	AuthorLogin             sql.NullString
	AuthorID                sql.NullInt64
	SubjectNumber           sql.NullInt32
	SubjectState            sql.NullString
	SubjectMerged           sql.NullBool
	SubjectStateReason      sql.NullString
}

func (q *Queries) UpsertNotification(ctx context.Context, arg UpsertNotificationParams) (Notification, error) {
	row := q.db.QueryRowContext(ctx, upsertNotification,
		arg.GithubID,
		arg.RepositoryID,
		arg.PullRequestID,
		arg.SubjectType,
		arg.SubjectTitle,
		arg.SubjectUrl,
		arg.SubjectLatestCommentUrl,
		arg.Reason,
		arg.GithubUnread,
		arg.GithubUpdatedAt,
		arg.GithubLastReadAt,
		arg.GithubUrl,
		arg.GithubSubscriptionUrl,
		arg.Payload,
		arg.SubjectRaw,
		arg.SubjectFetchedAt,
		arg.AuthorLogin,
		arg.AuthorID,
		arg.SubjectNumber,
		arg.SubjectState,
		arg.SubjectMerged,
		arg.SubjectStateReason,
	)
	var i Notification
	err := row.Scan(
		&i.ID,
		&i.GithubID,
		&i.RepositoryID,
		&i.PullRequestID,
		&i.SubjectType,
		&i.SubjectTitle,
		&i.SubjectUrl,
		&i.SubjectLatestCommentUrl,
		&i.Reason,
		&i.Archived,
		&i.GithubUnread,
		&i.GithubUpdatedAt,
		&i.GithubLastReadAt,
		&i.GithubUrl,
		&i.GithubSubscriptionUrl,
		&i.ImportedAt,
		&i.Payload,
		&i.SubjectRaw,
		&i.SubjectFetchedAt,
		&i.AuthorLogin,
		&i.AuthorID,
		&i.IsRead,
		&i.Muted,
		&i.SnoozedUntil,
		&i.EffectiveSortDate,
		&i.SnoozedAt,
		&i.Starred,
		&i.Filtered,
		pq.Array(&i.TagIds),
		&i.SubjectNumber,
		&i.SubjectState,
		&i.SubjectMerged,
		&i.SubjectStateReason,
	)
	return i, err
}
